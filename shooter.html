<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D FPS Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #container { position: absolute; width: 100%; height: 100%; }
        #hud {
            position: absolute; width: 100%; height: 100%; 
            pointer-events: none; z-index: 1;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px; margin-top: -10px; margin-left: -10px;
            color: white; text-align: center; font-size: 24px;
        }
        #health, #ammo, #wave, #score, #high-score {
            position: absolute; padding: 10px;
            background-color: rgba(0, 0, 0, 0.5); color: white;
            border-radius: 5px;
        }
        #health { bottom: 20px; left: 20px; }
        #ammo { bottom: 20px; right: 20px; }
        #wave { top: 20px; left: 20px; }
        #score { top: 20px; right: 20px; }
        #high-score { top: 60px; right: 20px; }
        #headshot-indicator {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translateX(-50%);
            color: red;
            font-weight: bold;
            font-size: 28px;
            text-shadow: 2px 2px 4px #000000;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #game-over, #instructions, #pause-menu {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8); color: white;
            padding: 20px; border-radius: 10px; text-align: center;
        }
        #game-over, #pause-menu { display: none; }
        button {
            margin-top: 20px; padding: 10px 20px;
            font-size: 16px; cursor: pointer;
        }
        .health-bar {
            position: absolute;
            width: 30px;
            height: 4px;
            background-color: #333;
            border-radius: 2px;
        }
        .health-bar-fill {
            height: 100%;
            background-color: #f00;
            border-radius: 2px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="hud">
        <div id="crosshair">+</div>
        <div id="health">Health: 100</div>
        <div id="ammo">Ammo: 30</div>
        <div id="wave">Wave: 1</div>
        <div id="score">Score: 0</div>
        <div id="high-score">High Score: 0</div>
        <div id="headshot-indicator">HEADSHOT +100</div>
    </div>
    <div id="game-over">
        <h2>Game Over</h2>
        <p>You survived <span id="final-wave">0</span> waves</p>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-button">Play Again</button>
    </div>
    <div id="pause-menu">
        <h2>Game Paused</h2>
        <button id="resume-button">Resume Game</button>
        <button id="quit-button">Quit Game</button>
    </div>
    <div id="instructions">
        <h2>Blast</h2>
        <p><strong>Controls:</strong></p>
        <p>WASD - Move</p>
        <p>Mouse - Aim</p>
        <p>Left Click - Shoot</p>
        <p>R - Reload</p>
        <p>Space - Jump</p>
        <p>ESC - Pause Game</p>
        <button id="start-button">Start Game</button>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';

        // Game state
        const state = {
            playerHealth: 100,
            ammo: 30,
            maxAmmo: 30,
            wave: 1,
            enemies: [],
            bullets: [],
            gameOver: false,
            gameStarted: false,
            paused: false,
            playerSpeed: 300.0,
            enemyHealthBars: [],
            score: 0,
            highScore: localStorage.getItem('fps_high_score') || 0
        };

        // Update score display
        document.getElementById('score').textContent = `Score: ${state.score}`;
        document.getElementById('high-score').textContent = `High Score: ${state.highScore}`;

        // Setup renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Setup scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Setup camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.7;

        // Add lights
        scene.add(new THREE.AmbientLight(0x404040));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        scene.add(light);

        // Create floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshPhongMaterial({ color: 0x999999 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Create walls - make them thicker and taller
        createWall(-50, 0, 0, 5, 10, 100); // Left wall
        createWall(50, 0, 0, 5, 10, 100);  // Right wall
        createWall(0, 0, -50, 100, 10, 5); // Back wall
        createWall(0, 0, 50, 100, 10, 5);  // Front wall

        // Create more obstacles throughout the map
        createBox(-10, 1, -8, 2, 4, 2);
        createBox(10, 1, -5, 2, 4, 2);
        createBox(0, 1, 10, 2, 4, 2);
        
        // Add more pillars throughout the landscape
        createBox(-20, 1, -20, 2, 6, 2);
        createBox(20, 1, -20, 2, 6, 2);
        createBox(-20, 1, 20, 2, 6, 2);
        createBox(20, 1, 20, 2, 6, 2);
        
        // Add some random pillars
        for (let i = 0; i < 10; i++) {
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            const height = 3 + Math.random() * 5;
            createBox(x, 1, z, 2, height, 2);
        }
        
        // Add some platforms
        createBox(-15, 2, 0, 8, 0.5, 8);
        createBox(15, 3, -15, 8, 0.5, 8);

        // Player controls
        const controls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            canJump: true,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3()
        };

        // Mouse look
        const pitchObject = new THREE.Object3D();
        pitchObject.add(camera);
        const yawObject = new THREE.Object3D();
        yawObject.position.y = 1.7;
        yawObject.add(pitchObject);
        scene.add(yawObject);

        // Weapon
        const weapon = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.1, 0.5),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        weapon.position.set(0.3, -0.3, -0.5);
        camera.add(weapon);

        // Bullet geometry and material
        const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        // Raycaster for shooting
        const raycaster = new THREE.Raycaster();

        // Setup event listeners
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        window.addEventListener('resize', onWindowResize);
        
        document.getElementById('start-button').addEventListener('click', startGame);
        document.getElementById('restart-button').addEventListener('click', restartGame);
        document.getElementById('resume-button').addEventListener('click', togglePause);
        document.getElementById('quit-button').addEventListener('click', quitGame);

        function onKeyDown(event) {
            if (!state.gameStarted || state.gameOver) return;
            
            switch (event.code) {
                case 'KeyW': controls.moveForward = true; break;
                case 'KeyS': controls.moveBackward = true; break;
                case 'KeyA': controls.moveLeft = true; break;
                case 'KeyD': controls.moveRight = true; break;
                case 'Space': 
                    if (controls.canJump) {
                        controls.velocity.y = 80; // Reduced from 350 to 80 for a more realistic jump
                        controls.canJump = false;
                    } 
                    break;
                case 'KeyR': reload(); break;
                case 'Escape': 
                    event.preventDefault();
                    togglePause(); 
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': controls.moveForward = false; break;
                case 'KeyS': controls.moveBackward = false; break;
                case 'KeyA': controls.moveLeft = false; break;
                case 'KeyD': controls.moveRight = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                pitchObject.rotation.x -= event.movementY * 0.002;
                pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
                yawObject.rotation.y -= event.movementX * 0.002;
            }
        }

        function onMouseDown(event) {
            if (event.button === 0 && document.pointerLockElement === document.body && !state.gameOver && !state.paused) {
                shoot();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function togglePause() {
            if (state.gameOver) return;
            
            state.paused = !state.paused;
            
            if (state.paused) {
                document.getElementById('pause-menu').style.display = 'block';
                document.exitPointerLock();
            } else {
                document.getElementById('pause-menu').style.display = 'none';
                document.body.requestPointerLock();
            }
        }

        function quitGame() {
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            state.gameStarted = false;
            state.paused = false;
            
            // Reset game state
            state.playerHealth = 100;
            state.ammo = state.maxAmmo;
            state.wave = 1;
            state.score = 0;
            
            // Clear enemies and bullets
            for (let enemy of state.enemies) {
                scene.remove(enemy);
            }
            state.enemies = [];
            
            for (let bullet of state.bullets) {
                scene.remove(bullet);
            }
            state.bullets = [];
            
            // Reset position
            yawObject.position.set(0, 1.7, 0);
            controls.velocity.set(0, 0, 0);
        }

        function createWall(x, y, z, width, height, depth) {
            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth),
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            wall.position.set(x, y + height/2, z);
            scene.add(wall);
        }

        function createBox(x, y, z, width, height, depth) {
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth),
                new THREE.MeshPhongMaterial({ color: 0xA9A9A9 })
            );
            box.position.set(x, y + height/2, z);
            scene.add(box);
        }

        function createEnemy(x, z, type = 'regular') {
            const enemyGroup = new THREE.Group();
            
            // Set properties based on enemy type
            let color, scale, health, speed;
            
            if (type === 'boss') {
                color = 0x880000; // Darker red for bosses
                scale = 1.5;      // Larger size
                health = 150 + state.wave * 10; // Much more health
                speed = 0.03 + (state.wave * 0.002); // Slower but increases with wave
            } else {
                color = 0xCC0000; // Regular red
                scale = 1.0;      // Normal size
                health = 50 + state.wave * 5; // Regular health
                speed = 0.05 + (state.wave * 0.005); // Regular speed
            }
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(1 * scale, 2.2 * scale, 1 * scale);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.1 * scale;
            enemyGroup.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.8 * scale);
            const headMaterial = new THREE.MeshPhongMaterial({ color: color });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.6 * scale;
            head.userData.isHead = true;
            enemyGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.BoxGeometry(0.4 * scale, 1.2 * scale, 0.4 * scale);
            const armMaterial = new THREE.MeshPhongMaterial({ color: color });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.7 * scale, 1.1 * scale, 0);
            enemyGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.7 * scale, 1.1 * scale, 0);
            enemyGroup.add(rightArm);
            
            // Position
            enemyGroup.position.set(x, 0, z);
            scene.add(enemyGroup);
            
            // Add enemy data
            enemyGroup.userData = {
                health: health,
                maxHealth: health,
                speed: speed,
                lastAttack: 0,
                head: head,
                type: type,
                scale: scale
            };
            
            // Create health bar HTML element
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'health-bar';
            healthBarContainer.style.display = 'none';
            
            // Make boss health bars wider
            if (type === 'boss') {
                healthBarContainer.style.width = '60px';
            }
            
            const healthBarFill = document.createElement('div');
            healthBarFill.className = 'health-bar-fill';
            healthBarContainer.appendChild(healthBarFill);
            
            document.getElementById('hud').appendChild(healthBarContainer);
            
            // Store reference to health bar
            enemyGroup.userData.healthBar = {
                container: healthBarContainer,
                fill: healthBarFill
            };
            
            state.enemies.push(enemyGroup);
            state.enemyHealthBars.push(healthBarContainer);
            
            return enemyGroup;
        }

        function spawnEnemies() {
            // Clear any existing enemies
            for (let enemy of state.enemies) {
                scene.remove(enemy);
                if (enemy.userData.healthBar && enemy.userData.healthBar.container) {
                    enemy.userData.healthBar.container.remove();
                }
            }
            state.enemies = [];
            state.enemyHealthBars = [];
            
            // Calculate number of enemies based on wave
            const regularEnemyCount = Math.min(3 + Math.floor(state.wave * 1.5), 20);
            
            // Determine if this wave should have boss enemies (every 2 waves)
            const isBossWave = state.wave % 2 === 0 && state.wave > 0;
            const bossCount = isBossWave ? Math.min(1 + Math.floor(state.wave / 6), 3) : 0;
            
            // Spawn regular enemies
            for (let i = 0; i < regularEnemyCount; i++) {
                spawnEnemyAtValidPosition('regular');
            }
            
            // Spawn boss enemies if it's a boss wave
            if (isBossWave) {
                for (let i = 0; i < bossCount; i++) {
                    spawnEnemyAtValidPosition('boss');
                }
            }
            
            // Update wave display
            document.getElementById('wave').textContent = `Wave: ${state.wave}`;
        }

        function shoot() {
            if (state.ammo <= 0) {
                reload();
                return;
            }
            
            state.ammo--;
            document.getElementById('ammo').textContent = `Ammo: ${state.ammo}`;
            
            // Create visible bullet
            const bulletPosition = new THREE.Vector3(0, 0, -0.5);
            bulletPosition.applyMatrix4(weapon.matrixWorld);
            
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(bulletPosition);
            
            // Get direction from camera
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const bulletDirection = raycaster.ray.direction.clone();
            
            bullet.userData = {
                velocity: bulletDirection.multiplyScalar(1),
                timeCreated: Date.now()
            };
            
            scene.add(bullet);
            state.bullets.push(bullet);
            
            // Check for hits
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let hit of intersects) {
                // Check if we hit an enemy part
                if (hit.object.parent && state.enemies.includes(hit.object.parent)) {
                    const enemy = hit.object.parent;
                    
                    // Check if it's a headshot
                    let damage = 15;
                    let isHeadshot = false;
                    
                    if (hit.object.userData.isHead) {
                        damage = 40; // Headshots do more damage
                        isHeadshot = true;
                        
                        // Visual feedback for headshot only if it kills the enemy
                        if (enemy.userData.health <= damage) {
                            const headshotIndicator = document.getElementById('headshot-indicator');
                            headshotIndicator.style.opacity = '1';
                            
                            setTimeout(() => {
                                headshotIndicator.style.opacity = '0';
                            }, 1000);
                            
                            // Add score for headshot kill
                            // Bosses are worth more points
                            const points = enemy.userData.type === 'boss' ? 250 : 100;
                            addScore(points);
                        }
                    }
                    
                    enemy.userData.health -= damage;
                    
                    // Update health bar
                    const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
                    enemy.userData.healthBar.fill.style.width = `${Math.max(0, healthPercent * 100)}%`;
                    
                    // Flash red when hit
                    enemy.children.forEach(part => {
                        if (part.material) {
                            const originalColor = part.material.color.clone();
                            part.material.color.setHex(0xFF0000);
                            
                            setTimeout(() => {
                                part.material.color.copy(originalColor);
                            }, 100);
                        }
                    });
                    
                    if (enemy.userData.health <= 0) {
                        // Add score for kill if not already counted from headshot
                        if (!isHeadshot) {
                            // Bosses are worth more points
                            const points = enemy.userData.type === 'boss' ? 150 : 50;
                            addScore(points);
                        }
                        killEnemy(enemy);
                    }
                    break;
                }
            }
            
            // Show weapon recoil
            weapon.position.z += 0.05;
            setTimeout(() => {
                weapon.position.z -= 0.05;
            }, 50);
            
            if (state.ammo <= 0) {
                reload();
            }
        }

        function reload() {
            setTimeout(() => {
                state.ammo = state.maxAmmo;
                document.getElementById('ammo').textContent = `Ammo: ${state.ammo}`;
            }, 2000);
        }

        function killEnemy(enemy) {
            const index = state.enemies.indexOf(enemy);
            if (index > -1) {
                state.enemies.splice(index, 1);
                
                // Remove health bar
                if (enemy.userData.healthBar && enemy.userData.healthBar.container) {
                    enemy.userData.healthBar.container.remove();
                    
                    const barIndex = state.enemyHealthBars.indexOf(enemy.userData.healthBar.container);
                    if (barIndex > -1) {
                        state.enemyHealthBars.splice(barIndex, 1);
                    }
                }
            }
            scene.remove(enemy);
            
            if (state.enemies.length === 0) {
                state.wave++;
                spawnEnemies();
            }
        }

        function takeDamage(amount) {
            state.playerHealth -= amount;
            document.getElementById('health').textContent = `Health: ${state.playerHealth}`;
            
            if (state.playerHealth <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            state.gameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-wave').textContent = state.wave;
            document.getElementById('final-score').textContent = state.score;
            document.exitPointerLock();
        }

        function startGame() {
            document.getElementById('instructions').style.display = 'none';
            state.gameStarted = true;
            document.body.requestPointerLock();
            spawnEnemies();
            animate();
        }

        function restartGame() {
            state.playerHealth = 100;
            state.ammo = state.maxAmmo;
            state.wave = 1;
            state.gameOver = false;
            state.score = 0;
            
            document.getElementById('health').textContent = `Health: ${state.playerHealth}`;
            document.getElementById('ammo').textContent = `Ammo: ${state.ammo}`;
            document.getElementById('score').textContent = `Score: ${state.score}`;
            document.getElementById('game-over').style.display = 'none';
            
            // Remove all enemies and their health bars
            for (let enemy of state.enemies) {
                scene.remove(enemy);
                if (enemy.userData.healthBar && enemy.userData.healthBar.container) {
                    enemy.userData.healthBar.container.remove();
                }
            }
            state.enemies = [];
            state.enemyHealthBars = [];
            
            // Remove all bullets
            for (let bullet of state.bullets) {
                scene.remove(bullet);
            }
            state.bullets = [];
            
            yawObject.position.set(0, 1.7, 0);
            controls.velocity.set(0, 0, 0);
            
            spawnEnemies();
            document.body.requestPointerLock();
        }

        function updatePlayer(delta) {
            // Apply friction to horizontal movement
            controls.velocity.x -= controls.velocity.x * 10.0 * delta;
            controls.velocity.z -= controls.velocity.z * 10.0 * delta;
            
            // Apply gravity
            controls.velocity.y -= 9.8 * 100.0 * delta; // Gravity
            
            // Get movement direction
            controls.direction.z = Number(controls.moveForward) - Number(controls.moveBackward);
            controls.direction.x = Number(controls.moveLeft) - Number(controls.moveRight);
            controls.direction.normalize();
            
            // Apply movement forces
            if (controls.moveForward || controls.moveBackward) {
                controls.velocity.z -= controls.direction.z * state.playerSpeed * delta;
            }
            if (controls.moveLeft || controls.moveRight) {
                controls.velocity.x -= controls.direction.x * state.playerSpeed * delta;
            }
            
            // Move player
            yawObject.translateX(controls.velocity.x * delta);
            yawObject.translateY(controls.velocity.y * delta);
            yawObject.translateZ(controls.velocity.z * delta);
            
            // Check if player is on the ground
            if (yawObject.position.y < 1.7) {
                controls.velocity.y = 0;
                yawObject.position.y = 1.7;
                controls.canJump = true;
            }
            
            // Add a visual feedback for jumping
            if (!controls.canJump) {
                // Optional: Add camera bob or other visual effects for jumping
                // For example, slight camera tilt based on velocity
                pitchObject.rotation.z = controls.velocity.y * 0.0002;
            } else {
                // Reset any jump-related visual effects
                pitchObject.rotation.z = 0;
            }
        }

        function updateEnemies(delta) {
            for (let enemy of state.enemies) {
                // Store original position in case we need to revert due to collision
                const originalX = enemy.position.x;
                const originalZ = enemy.position.z;
                
                // Calculate direction to player
                const direction = new THREE.Vector3();
                direction.subVectors(yawObject.position, enemy.position).normalize();
                
                // Try to move enemy
                enemy.position.x += direction.x * enemy.userData.speed;
                enemy.position.z += direction.z * enemy.userData.speed;
                
                // Check for collisions
                if (checkEnemyCollisions(enemy)) {
                    // If collision occurred, try moving in just X direction
                    enemy.position.x = originalX + direction.x * enemy.userData.speed;
                    enemy.position.z = originalZ;
                    
                    // Check again
                    if (checkEnemyCollisions(enemy)) {
                        // If still colliding, try moving in just Z direction
                        enemy.position.x = originalX;
                        enemy.position.z = originalZ + direction.z * enemy.userData.speed;
                        
                        // Final check
                        if (checkEnemyCollisions(enemy)) {
                            // If all movements cause collisions, stay in place
                            enemy.position.x = originalX;
                            enemy.position.z = originalZ;
                        }
                    }
                }
                
                // Keep enemies within arena bounds
                const arenaSize = 48;
                enemy.position.x = Math.max(-arenaSize, Math.min(arenaSize, enemy.position.x));
                enemy.position.z = Math.max(-arenaSize, Math.min(arenaSize, enemy.position.z));
                
                // Make enemy face player
                enemy.lookAt(yawObject.position);
                
                // Check if enemy is close enough to attack
                const distance = enemy.position.distanceTo(yawObject.position);
                if (distance < 2) {
                    // Only attack at a certain rate
                    const now = Date.now();
                    if (now - enemy.userData.lastAttack > 1000) { // Attack once per second
                        takeDamage(1);
                        enemy.userData.lastAttack = now;
                    }
                }
            }
        }

        function updateBullets(delta) {
            const now = Date.now();
            
            for (let i = state.bullets.length - 1; i >= 0; i--) {
                const bullet = state.bullets[i];
                
                // Move bullet
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta * 300));
                
                // Remove bullets after 2 seconds or if they go too far
                if (now - bullet.userData.timeCreated > 2000 || 
                    bullet.position.distanceTo(yawObject.position) > 100) {
                    scene.remove(bullet);
                    state.bullets.splice(i, 1);
                }
            }
        }

        function updateHealthBars() {
            for (let i = 0; i < state.enemies.length; i++) {
                const enemy = state.enemies[i];
                if (enemy.userData.healthBar) {
                    // Project 3D position to 2D screen position
                    const position = new THREE.Vector3();
                    position.setFromMatrixPosition(enemy.matrixWorld);
                    
                    // Adjust height based on enemy scale
                    const scale = enemy.userData.scale || 1.0;
                    position.y += 3.2 * scale;
                    
                    // Convert 3D position to 2D screen position
                    const vector = position.project(camera);
                    
                    // Convert to CSS coordinates
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Update health bar position
                    const healthBar = enemy.userData.healthBar.container;
                    healthBar.style.left = `${x - (30/2)}px`;
                    healthBar.style.top = `${y - 5}px`;
                    
                    // Only show health bar if enemy is in front of camera
                    const isFacing = vector.z < 1;
                    healthBar.style.display = isFacing ? 'block' : 'none';
                }
            }
        }

        function checkCollisions() {
            // Create a sphere representing the player's collision body
            const playerRadius = 1.0;
            const playerPosition = new THREE.Vector3();
            yawObject.getWorldPosition(playerPosition);
            
            // Check collision with walls and obstacles
            const obstacles = scene.children.filter(child => 
                child.geometry && 
                (child.geometry.type === 'BoxGeometry' || child.geometry.type === 'PlaneGeometry')
            );
            
            for (const obstacle of obstacles) {
                if (obstacle === floor) continue; // Skip floor
                
                // Get obstacle's bounding box
                if (!obstacle.geometry.boundingBox) {
                    obstacle.geometry.computeBoundingBox();
                }
                
                const box = obstacle.geometry.boundingBox.clone();
                box.applyMatrix4(obstacle.matrixWorld);
                
                // Simple collision check - keep player outside the box
                const minDistance = playerRadius;
                
                // Check if player is inside or too close to the box
                if (playerPosition.x > box.min.x - minDistance && 
                    playerPosition.x < box.max.x + minDistance && 
                    playerPosition.z > box.min.z - minDistance && 
                    playerPosition.z < box.max.z + minDistance &&
                    playerPosition.y > box.min.y - minDistance && 
                    playerPosition.y < box.max.y + minDistance) {
                    
                    // Find the closest face to push the player away from
                    const distances = [
                        Math.abs(playerPosition.x - box.min.x), // Distance to left face
                        Math.abs(playerPosition.x - box.max.x), // Distance to right face
                        Math.abs(playerPosition.z - box.min.z), // Distance to back face
                        Math.abs(playerPosition.z - box.max.z)  // Distance to front face
                    ];
                    
                    const minIndex = distances.indexOf(Math.min(...distances));
                    
                    // Push player away from the closest face
                    switch (minIndex) {
                        case 0: // Left face
                            yawObject.position.x = box.min.x - minDistance;
                            break;
                        case 1: // Right face
                            yawObject.position.x = box.max.x + minDistance;
                            break;
                        case 2: // Back face
                            yawObject.position.z = box.min.z - minDistance;
                            break;
                        case 3: // Front face
                            yawObject.position.z = box.max.z + minDistance;
                            break;
                    }
                }
            }
            
            // Keep player within the arena bounds
            const arenaSize = 48; // Slightly less than wall positions to account for wall thickness
            yawObject.position.x = Math.max(-arenaSize, Math.min(arenaSize, yawObject.position.x));
            yawObject.position.z = Math.max(-arenaSize, Math.min(arenaSize, yawObject.position.z));
        }

        function animate() {
            if (state.gameOver) return;
            
            requestAnimationFrame(animate);
            
            const delta = 0.016; // Assume 60fps
            
            if (state.gameStarted && !state.gameOver && !state.paused) {
                updatePlayer(delta);
                checkCollisions(); // Add collision detection
                updateEnemies(delta);
                updateBullets(delta);
                updateHealthBars();
            }
            
            renderer.render(scene, camera);
        }

        // Add score function
        function addScore(points) {
            state.score += points;
            document.getElementById('score').textContent = `Score: ${state.score}`;
            
            // Update high score if needed
            if (state.score > state.highScore) {
                state.highScore = state.score;
                document.getElementById('high-score').textContent = `High Score: ${state.highScore}`;
                localStorage.setItem('fps_high_score', state.highScore);
            }
        }

        // Add this function to check enemy collisions with obstacles
        function checkEnemyCollisions(enemy) {
            const enemyRadius = enemy.userData.scale ? enemy.userData.scale * 0.5 : 0.5;
            
            // Check collision with walls and obstacles
            const obstacles = scene.children.filter(child => 
                child.geometry && 
                (child.geometry.type === 'BoxGeometry' || child.geometry.type === 'PlaneGeometry') &&
                child !== floor
            );
            
            // Also check collision with other enemies
            const otherEnemies = state.enemies.filter(e => e !== enemy);
            
            // Check obstacles first
            for (const obstacle of obstacles) {
                // Get obstacle's bounding box
                if (!obstacle.geometry.boundingBox) {
                    obstacle.geometry.computeBoundingBox();
                }
                
                const box = obstacle.geometry.boundingBox.clone();
                box.applyMatrix4(obstacle.matrixWorld);
                
                // Simple collision check - keep enemy outside the box
                const minDistance = enemyRadius;
                
                // Check if enemy is inside or too close to the box
                if (enemy.position.x > box.min.x - minDistance && 
                    enemy.position.x < box.max.x + minDistance && 
                    enemy.position.z > box.min.z - minDistance && 
                    enemy.position.z < box.max.z + minDistance) {
                    
                    // Find the closest face to push the enemy away from
                    const distances = [
                        Math.abs(enemy.position.x - box.min.x), // Distance to left face
                        Math.abs(enemy.position.x - box.max.x), // Distance to right face
                        Math.abs(enemy.position.z - box.min.z), // Distance to back face
                        Math.abs(enemy.position.z - box.max.z)  // Distance to front face
                    ];
                    
                    const minIndex = distances.indexOf(Math.min(...distances));
                    
                    // Push enemy away from the closest face
                    switch (minIndex) {
                        case 0: // Left face
                            enemy.position.x = box.min.x - minDistance;
                            break;
                        case 1: // Right face
                            enemy.position.x = box.max.x + minDistance;
                            break;
                        case 2: // Back face
                            enemy.position.z = box.min.z - minDistance;
                            break;
                        case 3: // Front face
                            enemy.position.z = box.max.z + minDistance;
                            break;
                    }
                    
                    return true; // Collision detected
                }
            }
            
            // Check collision with other enemies
            for (const otherEnemy of otherEnemies) {
                const otherRadius = otherEnemy.userData.scale ? otherEnemy.userData.scale * 0.5 : 0.5;
                const minDistance = enemyRadius + otherRadius;
                
                const dx = enemy.position.x - otherEnemy.position.x;
                const dz = enemy.position.z - otherEnemy.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < minDistance) {
                    // Push enemies away from each other
                    const angle = Math.atan2(dz, dx);
                    const pushDistance = (minDistance - distance) / 2;
                    
                    enemy.position.x += Math.cos(angle) * pushDistance;
                    enemy.position.z += Math.sin(angle) * pushDistance;
                    
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }
        
        // Helper function to spawn an enemy at a valid position
        function spawnEnemyAtValidPosition(type) {
            let x, z;
            let validPosition = false;
            let attempts = 0;
            const maxAttempts = 50;
            
            // Create a temporary enemy to check collisions
            const tempEnemy = new THREE.Object3D();
            tempEnemy.userData = { scale: type === 'boss' ? 1.5 : 1.0 };
            
            while (!validPosition && attempts < maxAttempts) {
                // Generate random position
                if (type === 'boss') {
                    // Position bosses further away
                    do {
                        x = (Math.random() - 0.5) * 70;
                        z = (Math.random() - 0.5) * 70;
                    } while (Math.sqrt(x*x + z*z) < 25); // Keep bosses further away
                } else {
                    // Regular enemies
                    do {
                        x = (Math.random() - 0.5) * 80;
                        z = (Math.random() - 0.5) * 80;
                    } while (Math.sqrt(x*x + z*z) < 15); // Keep enemies at least 15 units away
                }
                
                // Check if position is valid
                tempEnemy.position.set(x, 0, z);
                validPosition = !checkEnemyCollisions(tempEnemy);
                attempts++;
            }
            
            // If we found a valid position or ran out of attempts, create the enemy
            if (validPosition || attempts >= maxAttempts) {
                createEnemy(x, z, type);
            }
        }
    </script>
</body>
</html> 